讲红黑树之前，我们首先来了解下下面几个概念：**二叉树，排序二叉树以及平衡二叉树**。

#### 一、二叉树

二叉树指的是每个节点最多只能有两个字数的有序树。通常左边的子树称为`左子树` ，右边的子树称为`右子树` 。这里说的有序树强调的是二叉树的左子树和右子树的次序不能随意颠倒。

二叉树简单的示意图如下：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png.jpeg" alt="img" style="zoom:50%;" />

代码定义：

```java
class Node {
    T data;
    Node left;
    Node right;
}
12345
```

#### 二、排序二叉树

所谓排序二叉树，顾名思义，排序二叉树是有顺序的，它是一种特殊结构的二叉树，我们可以对树中所有节点进行排序和检索。

**性质**

- 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若她的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 具有递归性，排序二叉树的左子树、右子树也是排序二叉树。

排序二叉树简单示意图：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png-6795412.png" alt="排序二叉树" style="zoom:50%;" />

#### 三、排序二叉树退化成链表

​		排序二叉树的左子树上所有节点的值小于根节点的值，右子树上所有节点的值大于根节点的值，当我们插入一组元素正好是有序的时候，这时会让排序二叉树退化成链表。

​		正常情况下，排序二叉树是如下图这样的：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png-20200414003022847.jpeg" alt="img" style="zoom:50%;" />

​		但是，当插入的一组元素正好是有序的时候，排序二叉树就变成了下边这样了，就变成了普通的链表结构，如下图所示:

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png-20200414003034065.jpeg" alt="img" style="zoom:50%;" />

​		正常情况下的排序二叉树检索效率类似于二分查找，二分查找的时间复杂度为 O(log n)，但是如果排序二叉树退化成链表结构，那么检索效率就变成了线性的 O(n) 的，这样相对于 O(log n) 来说，检索效率肯定是要差不少的。

**思考，二分查找和正常的排序二叉树的时间复杂度都是 O(log n)，那么为什么是O(log n) ？**

​		关于 O(log n) 的分析下面这篇文章讲解的非常好，感兴趣的可以看下这篇文章 [二分查找的时间复杂度](https://github.com/JasonGaoH/KnowledgeSummary/blob/master/Docs/Algorithm/为什么说二分查找的时间复杂度是O(log n).md)，文章是拿二分查找来举例的，二分查找和平衡二叉树的时间复杂度是一样的，理解了二分查找的时间复杂度，再来理解平衡二叉树就不难了，这里就不赘述了。

​		继续回到我们的主题上，为了解决排序二叉树在特殊情况下会退化成链表的问题（链表的检索效率是 O(n) 相对正常二叉树来说要差不少），所以有人发明了`平衡二叉树`和`红黑树`类似的平衡树。

#### 四、平衡二叉树

​		平衡二叉数又被称为 AVL 树，AVL 树的名字来源于它的发明作者 G.M. Adelson-Velsky 和 E.M. Landis，取自两人名字的首字母。

​		官方定义：它或者是一颗空树，或者具有以下性质的排序二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

​		两个条件：

- 平衡二叉树必须是排序二叉树，也就是说平衡二叉树他的左子树所有节点的值必须小于根节点的值，它的右子树上所有节点的值必须大于它的根节点的值。
- 左子树和右子树的深度之差的绝对值不超过1。

#### 五、红黑树

​		讲了这么多概念，接下来主角红黑树终于要上场了。

​		**为什么有红黑树？**

​		其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，红黑树最早是由 Rudolf Bayer 于 1972 年发明的。**红黑树首先肯定是一个排序二叉树**，它在**每个节点上增加了一个存储位来表示节点的颜色**，可以是 RED 或 BLACK 。

​		Java 中实现红黑树大概结构图如下所示：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png-20200414003134648.jpeg" alt="img" style="zoom:50%;" />

##### 1.红黑树的特性

- 性质1：每个节点要么是红色，要么是黑色。
- 性质2：根节点永远是黑色的。
- 性质3：所有的叶子节点都是空节点（即null），并且是黑色的。
- 性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点。）
- 性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

​        针对上面的 5 种性质，我们简单理解下，**对于性质 1 和性质 2** ，相当于是对红黑树每个节点的约束，根节点是黑色，其他的节点要么是红色，要么是黑色。

​		**对于性质 3** 中指定红黑树的每个叶子节点都是空节点，而且叶子节点都是黑色，但 Java 实现的红黑树会使用 null 来代表空节点，因此我们在遍历 Java里的红黑树的时候会看不到叶子节点，而看到的是每个叶子节点都是红色的，这一点需要注意。

​		**对于性质 5**，这里我们需要注意的是，这里的描述是从任一节点，从任一节点到它的子树的每个叶子节点黑色节点的数量都是相同的，这个数量被称为这个节点的黑高。如果我们从根节点出发到每个叶子节点的路径都包含相同数量的黑色节点，这个黑色节点的数量被称为树的黑色高度。**树的黑色高度和节点的黑色高度是不一样的**，这里要注意区分。

​		其实到这里有人可能会问了，红黑树的性质说了一大堆，那是不是说只要保证红黑树的节点是红黑交替就能保证树是平衡的呢？其实不是这样的，我们可以看来看下面这张图：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/format,png-20200414003204871.jpeg" alt="img" style="zoom:50%;" />

​		左边的子树都是黑色节点，但是这个红黑树依然是平衡的，5 条性质它都满足。这个树的黑色高度为 3，从根节点到叶子节点的最短路径长度是 2，该路径上全是黑色节点，包括叶子节点，从根节点到叶子节点最长路径为 4，每个黑色节点之间会插入红色节点。

​		**通过上面的性质 4 和性质 5，其实上保证了没有任何一条路径会比其他路径长出两倍，所以这样的红黑树是平衡的。**其实这算是一个推论，红黑树在**最差情况下**，最长的路径都不会比最短的路径长出两倍。其实红黑树**并不是真正的平衡二叉树**，它只能保证大致是平衡的，因为红黑树的**高度不会无限增高**，在实际应用用，红黑树的统计性能要高于平衡二叉树，但极端性能略差。



##### 2.红黑树的操作

​		红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么**查找过程和二叉查找树一样，比较简单**，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。

###### 1.旋转操作

​		在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为**左旋和右旋**，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。

###### 2.插入操作

​		红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要**进行调整，以满足红黑树的性质**。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？**答案是红色**，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。**如果插入的节点是红色，此时所有路径上的黑色节点数量不变**，仅可能会出现两个连续的红色节点的情况。这种情况下，**通过变色和旋转进行调整即可，比之前的简单多了**。

​		首先约定**插入的新节点的颜色都为红色**。然后将该节点插入的按二叉查找树的规则插入到树中。这个节点后文称为N。

1.  **根节点为空**。这种情况，将N的颜色改为黑色即可。
2.  **N的父节点为黑色**。这种情况不需要做修改。
3.  **N的父节点为红色**（根据性质3，**N的祖父节点必为黑色**）。

-   **N的叔父节点为红色**。这种情况，将N的父节点和叔父节点的**颜色都改为黑色**，若祖父节点是跟节点就将其改为黑色，否则将其颜色改为红色，并以祖父节点为插入的目标节点从情况1开始递归检测。

![情形3 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_insert_case_3.png)

-   **N的叔父节点为黑色， 且N和N的父节点在同一边**（即父节点为祖父的左儿子时，N也是父节点的左儿子。父节点为祖父节点的右儿子时。N也是父节点的右儿子）。以父节点为祖父节的左儿子为例，**将父节点改为黑色，祖父节点改为红色，然后以祖父节点为基准右旋**。（N为父节点右儿子时做相应的左旋。）

![情形5 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_insert_case_5.png)

-   **N的叔父节点为黑色，切N和N的父节点不在同一边**（即父节点为祖父的左儿子时，N是父节点的右儿子。父节点为祖父节点的右儿子时。N也是父节点左右儿子）。以父节点为祖父节点的左儿子为例。**以父节点为基准，进行左旋，然后以父节点为目标插入节点进入情况3的b情况进行操作**。

![情形4 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_insert_case_4.png)

###### 3.删除操作

​		删除的节点有两个儿子时，可以**转化为删除的节点只有一个儿子时的问题**。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的**左子树中的最大元素**、要么在它的**右子树中的最小元素**，并把它的**值转移到要删除的节点中**。接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。

​		那么所有情况都可以转化为删除只有一个儿子的节点的情况，我们约定这个要删除的节点为N（若N“没有”儿子节点，并用他的任意一个为叶子节点的儿子节点顶替即可）

1.  **N为红色节点时**。直接删除N，用它的黑色儿子代替它的位置。
2.  **N为黑色节点，且父节点为红色**。直接删除N，用它的儿子节点代替它的位置，并将该儿子节点改为黑色。
3.  **N为黑色节点，且父节点为黑色**。我们之间删除N，用它的儿子节点代替它，该儿子节点成为N'，将N’的颜色改为黑色。

-   N’的兄弟节点和兄弟节点的2个儿子都为黑色。交换兄弟节点和父节点的颜色即可。

![情形4 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_delete_case_4.png)

-   N‘的兄弟节点为黑色、且兄弟节点的红色儿子和兄弟节点在一边（即兄弟节点为左儿子时，红色儿子也为左儿子。兄弟节点为右儿子时，红色儿子也为右儿子）。我们以兄弟节点为右儿子为例。将祖父节点和兄弟节点的颜色互换，并将红色右儿子的颜色改为黑色，然后以祖父节点为基准左旋。（若兄弟节点为左儿子，则相应的右旋）

![情形6 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_delete_case_6.png)

-   N‘的兄弟节点为黑色、且兄弟节点的红儿子和兄弟节点不在一边（即兄弟节点为左儿子时，红色儿子也为右儿子。兄弟节点为右儿子时，红色儿子也为左儿子）。我们以兄弟结点为右儿子为例。将兄弟节点和它的红色儿子的颜色互换，然后以兄弟节点为基准右旋。此时对于N’来说就进入了上文b情况。（若兄弟节点为右儿子，则相应的左旋）

![情形5 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_delete_case_5.png)

-   N‘的兄弟节点为红色。以兄弟节点为右儿子为例，将父节点和兄弟节点的颜色互换，然后以父节点为基准左旋（若兄弟节点为左儿子则相应的右旋），此N’有一个黑色的兄弟节点，接下来N就可以进入a、b、c三种情况分别操作了。

![情形2 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_delete_case_2.png)

-   N‘的兄弟节为黑色，父节点也为黑色。此时将兄弟节点的颜色改为红色。然后以父节点为目标插入节点从头开始依次判断。

![情形3 示意图](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/Red-black_tree_delete_case_3.png)