# 排序

#### **冒泡排序**

```java
public void bubbleSort(int array[]) {
		int t = 0;
		for (int i = 0; i < array.length - 1; i++)
			for (int j = 0; j < array.length - 1 - i; j++)
				if (array[j] > array[j + 1]) {
					t = array[j];
					array[j] = array[j + 1];
					array[j + 1] = t;
				}
	}

private static <T extends Comparable<? super T>> void bubbleSort(T[] nums) {
    if (null == nums || nums.length == 0) {
      throw new RuntimeException("数组为null或长度为0");
    }

    T temp = null;
    int length = nums.length;
    //用于标识是否已经将序列排好序
    boolean isOrdered = false;
    for (int i = 0; i < length - 1; i++) {
      //每一趟开始前都假设已经有序
      isOrdered = true;
      for (int j = 0; j < length - 1 - i; j++) {
        if (nums[j].compareTo(nums[j + 1]) > 0) {
          temp = nums[j];
          nums[j] = nums[j + 1];
          nums[j + 1] = temp;
          //如果出现有元素交换，则表明此躺可能没有完成排序
          isOrdered = false;
        }
      }
      //如果当前趟都没有进行元素的交换，证明前面一趟比较已经排好序
      //直接跳出循环
      if (isOrdered) {
        break;
      }
    }
  }
```

 



#### 快速排序

**特点：高效，时间复杂度为nlogn。**
**采用分治法的思想：首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。**

```java
public void quickSort(int array[], int low, int high) {// 传入low=0，high=array.length-1;
		int pivot, p_pos, i, t;// pivot->位索引;p_pos->轴值。
		if (low < high) {
			p_pos = low;
			pivot = array[p_pos];
			for (i = low + 1; i <= high; i++)
				if (array[i] > pivot) {
					p_pos++;
					t = array[p_pos];
					array[p_pos] = array[i];
					array[i] = t;
				}
			t = array[low];
			array[low] = array[p_pos];
			array[p_pos] = t;
			// 分而治之
			quickSort(array, low, p_pos - 1);// 排序左半部分
			quickSort(array, p_pos + 1, high);// 排序右半部分
		}
```





测试demo：

```ruby
import java.util.Arrays;
public class sortTest {
	// 冒泡排序
	public void bubbleSort(int array[]) {
		int t = 0;
		for (int i = 0; i < array.length - 1; i++)
			for (int j = 0; j < array.length - 1 - i; j++)
				if (array[j] > array[j + 1]) {
					t = array[j];
					array[j] = array[j + 1];
					array[j + 1] = t;
				}
	}

	// 选择排序
	public void selectSort(int array[]) {
		int t = 0;
		for (int i = 0; i < array.length - 1; i++){
			int index=i;
			for (int j = i + 1; j < array.length; j++)
				if (array[index] > array[j])
					index=j;
			if(index!=i){ //找到了比array[i]小的则与array[i]交换位置
				t = array[i];
				array[i] = array[index];
				array[index] = t;
			}
		}
	}

public void insertionSort(int array[]) {
		int i, j, t = 0;
		for (i = 1; i < array.length; i++) {
			if(a[i]<a[i-1]){
				t = array[i];
				for (j = i - 1; j >= 0 && t < array[j]; j--)
					array[j + 1] = array[j];
				//插入array[i]
				array[j + 1] = t;
			}
		}
}

	// 分治法快速排序
	public void quickSort(int array[], int low, int high) {// 传入low=0，high=array.length-1;
		int pivot, p_pos, i, t;// pivot->位索引;p_pos->轴值。
		if (low < high) {
			p_pos = low;
			pivot = array[p_pos];
			for (i = low + 1; i <= high; i++)
				if (array[i] > pivot) {
					p_pos++;
					t = array[p_pos];
					array[p_pos] = array[i];
					array[i] = t;
				}
			t = array[low];
			array[low] = array[p_pos];
			array[p_pos] = t;
			// 分而治之
			quickSort(array, low, p_pos - 1);// 排序左半部分
			quickSort(array, p_pos + 1, high);// 排序右半部分
		}
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] array = { 37, 47, 23, 100, 19, 56, 56, 99, 9 };
		sortTest st = new sortTest();
		// st.bubbleSort(array);
		// st.selectSort(array);
		// st.insertionSort(array);
		st.quickSort(array, 0, array.length - 1);
		System.out.println("排序后：" + Arrays.toString(array));
	}
}
```