### Java微服务思想

#### 前言

​		最近几年微服务很火，大家都在建设微服务，仿佛不谈点微服务相关的技术，都显得不是那么主流了。

​		近几年见识到身边朋友的很多公司和团队都在尝试进行微服务的改变，但很多团队并没有实际微服务踩坑经验，很多团队甚至**强行为了微服务而去微服务**，最终写成一个**大型的分布式单体应用**，就是改造后的系统既没有微服务的快速扩容，灵活发布的特性，也让原本的单体应用失去了方便开发，部署容易的特性（项目拆为多份，开发部署复杂度都提高了），不得不说是**得不偿失**。

​		作者亲身经历和参与几个大型项目微服务的改造和建设。所以想作为实践者跟大家分享关于微服务的实际经验，帮助大家了解微服务的优缺点，从而可以结合自身业务做出更加合适的选择，作为本篇文章的三个主题，例如：

1. 什么是微服务？为什么要用微服务？
2. 微服务解决什么问题，又引入了什么问题？
3. 使用微服务应该要遵循哪些原则？什么样的情况你不应该使用微服务？

#### 一.什么是微服务？为什么要用微服务？

​		**什么是微服务？**

​		简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把单艘航母理解为的单体应用（防御差，机动性不好），把航母战斗群（调度复杂，维护费用高）理解为微服务。

​		大部分的开发者经历和开发过单体应用，无论是传统的 Servlet + JSP，还是 SSM，还是现在的 SpringBoot，它们都是**单体应用**，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下：

- 部署成本高（无论是修改1行代码，还是10行代码，都要**全量替换**）
- 改动影响大，风险高（不论代码改动多小，**成本都相同**）
- 因为成本高，风险高，所以导致部署频率低（**无法快速交付客户需求**）

​        当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊

![img](https://img-blog.csdnimg.cn/2019072910424137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW8yc2hpcWk=,size_16,color_FFFFFF,t_70)

#### 二.微服务解决什么问题，又引入了什么问题？

**我们先看看微服务能带给我们什么？微服务架构的特点：**

- 针对特定服务发布，影响小，风险小，成本低
- 频繁发布版本，快速交付需求
- 低成本扩容，弹性伸缩，适应云环境

**微服务在解决了快速响应和弹性伸缩的问题同时，它又给我们带来了什么问题**？

- 分布式系统的复杂性
- 部署，测试和监控的成本问题
- 分布式事务和CAP的相关问题

​        系统应用由原来的单体变成几十到几百个不同的工程，会所产生例如包括服务间的依赖，服务如何**拆封**，内部**接口规范**，**数据传递**等等问题，尤其是服务拆分，需要团队熟悉业务流程，懂得取舍，要保证拆分的粒度服务既符合“高内聚，低耦合”的基本原则，还要兼顾业务的发展以及公司的愿景，要还要说服团队成员为之努力，并且积极投入，在多方中间取得平衡。

​        对于分布式系统，部署，测试和监控都需要大量的中间件来支撑，而且中间件本身也要维护，原先单体应用很简单的事务问题 ，转到分布式环境就变得很复杂，分布式事务是采用简单的重试+补偿机制，还是采用二阶段提交协议等强一致性方法来解决，就要取决对业务场景的熟悉加上反复的权衡了，相同问题还包括对 CAP 模型的权衡，总之微服务对团队整体的技术栈水平整体要求更高



#### 三.使用微服务应该遵循哪些原则？

​		古人云：兵马未动，粮草先行。建设微服务是需要**建立长远规划**，不是像写CMS那样建好数据库表，然后就开始干活，这样十有八九是会失败的。我们要进行微服务改造前，架构师要提前做好规划，我们把这里分为三步，前期阶段，设计阶段，技术阶段

##### 前期阶段，大致要做好如下事情：

- 和多方充分沟通，确保能符合客户和组织的需求，并且得到认同
- 和团队沟通，让队友（开发/测试/运维）理解，并且积极投入
- 和业务部门沟通，指定版本计划和上线时间 

##### 设计阶段，参考 Sam Newman 的著作[《微服务设计》](https://book.douban.com/subject/26772677/)，单微服务必须要满足以下的条件，才符合微服务的基本要求：

- 标准的 REST 风格接口（基于 HTTP 和 JSON 格式）
- 独立部署，避免共享数据库（避免因为数据库而影响整个分布式系统）
- 业务上的高内聚，减少依赖（从设计上要避免服务过大或者太小） 

##### 庞大的分布式系统，需要强大基础设施来支撑，微服务涉及哪些基础设施？

- CI/CD和自动化（分布式系统几乎不可能通过人工手动发布）
- 虚拟化技术（要保证微服务运行环境隔离，目前行业主流的是使用 Docker 容器）
- 日志聚合，全链路监控（高度可观察和分析诊断问题）



#### 四.详解RESTful

**一.什么是RESTful 面向资源**

​		简单的说：RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。

​		先看REST是什么意思，英文Representational state transfer 表述性状态转移 其实就是对 资源 的表述性状态转移。（什么是表述性：就是指客户端请求一个资源，服务器拿到的这个资源，就是表述）

​		资源的地址 在web中就是URL （统一资源标识符）,资源是REST系统的核心概念。 所有的设计都是以资源为中心, 结合项目怎么识别资源

1.商品加入购物车 购物车

2.提交订单 订单

3.创建用户 用户 

围绕资源进行 添加，获取，修改，删除，以及对符合特定条件的资源进行列表操作 。针对资源设计接口

**二.关于规范与约束有哪些？**

RESTful 架构的核心规范与约束：统一接口

分为四个子约束：

1.每个资源都拥有一个资源标识，每个资源的资源标识可以用来唯一地标明该资源

2.消息的自描述性

3.资源的自描述性。

4.HATEOAS Hypermedia As The Engine Of Application State(超媒体作为应用状态引擎)

即客户只可以通过服务端所返回各结果中所包含的信息来得到下一步操作所需要的信息，如到底是向哪个URL发送请求等。也就是说，一个典型的REST服务不需要额外的文档标示通过哪些URL访问特定类型的资源，而是通过服务端返回的响应来标示到底能在该资源上执行什么样的操作

**三、资源的URL设计**

**1.通过URL来表示资源**

资源分为主资源与子资源

因为主资源是一类独立的资源 所以主资源应直接放在相对路径下：例如

若要表示主资源的实例：如果实例的ID=1，则这样表示： /goods/1

子资源：

一个实例的子资源可能是一个集合也可能是一个单一的子资源

子资源为图片集合：/goods/1/pictures

子资源为商品折扣的单子子资源：/goods/1/discount

**2.单数 vs. 复数**

获取用户1的信息，哪种方式更符合RESTful?

/api/users/1

/api/user/1

**3.相对路径 vs. 请求参数**

极光的RESTful API:

获取用户信息 GET /v1/users/{username} 参数放在路径中

获取用户信息 GET /v1/users?username=xxxxx 拼接的方式

获取应用管理员列表 GET /v1/admins?start={start}&count={count} ？后拼接参数的方式：这种方式一般作为过滤资源

**4.使用合适的动词 get delete put post**

选择请求接口的方式： get delete

PUT 在服务器更新资源（客户端提供改变后的完整资源）。

POST 在服务器新建一个资源

**5.使用标准的状态码**

**GET**

- 安全且幂等

- 获取表示

- 变更时获取表示（缓存）

- 200（OK） - 表示已在响应中发出

- 204（无内容） - 资源有空表示

- 301（Moved Permanently） - 资源的URI已被更新

- 303（See Other） - 其他（如，负载均衡）

- 304（not modified）- 资源未更改（缓存）

- 400 （bad request）- 指代坏请求（如，参数错误）

- 404 （not found）- 资源不存在

- 406 （not acceptable）- 服务端不支持所需表示

- 500 （internal server error）- 通用错误响应

- 503 （Service Unavailable）- 服务端当前无法处理请求

    **POST**

    - 不安全且不幂等
    - 使用服务端管理的（自动产生）的实例号创建资源
    - 创建子资源
    - 部分更新资源
    - 如果没有被修改，则不过更新资源（乐观锁）

    - 200（OK）- 如果现有资源已被更改

    - 201（created）- 如果新资源被创建
    - 202（accepted）- 已接受处理请求但尚未完成（异步处理）
    - 301（Moved Permanently）- 资源的URI被更新
    - 303（See Other）- 其他（如，负载均衡）
    - 400（bad request）- 指代坏请求
    - 404 （not found）- 资源不存在
    - 406 （not acceptable）- 服务端不支持所需表示
    - 409 （conflict）- 通用冲突
    - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
    - 415 （unsupported media type）- 接受到的表示不受支持
    - 500 （internal server error）- 通用错误响应
    - 503 （Service Unavailable）- 服务当前无法处理请求

    **PUT**

    - 不安全但幂等
    - 用客户端管理的实例号创建一个资源
    - 通过替换的方式更新资源
    - 如果未被修改，则更新资源（乐观锁）

    - 200 （OK）- 如果已存在资源被更改

    - 201 （created）- 如果新资源被创建
    - 301（Moved Permanently）- 资源的URI已更改
    - 303 （See Other）- 其他（如，负载均衡）
    - 400 （bad request）- 指代坏请求
    - 404 （not found）- 资源不存在
    - 406 （not acceptable）- 服务端不支持所需表示
    - 409 （conflict）- 通用冲突
    - 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
    - 415 （unsupported media type）- 接受到的表示不受支持
    - 500 （internal server error）- 通用错误响应
    - 503 （Service Unavailable）- 服务当前无法处理请求

    **DELETE**

    - 不安全但幂等
    - 删除资源

    - 200 （OK）- 资源已被删除

    - 301 （Moved Permanently）- 资源的URI已更改
    - 303 （See Other）- 其他，如负载均衡
    - 400 （bad request）- 指代坏请求
    - 404 （not found）- 资源不存在
    - 409 （conflict）- 通用冲突
    - 500 （internal server error）- 通用错误响应
    - 503 （Service Unavailable）- 服务端当前无法处理请求

    

