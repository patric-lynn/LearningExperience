### MySQL相关知识

#### MySQL基础框架

##### 1.基本架构

> 你知道MySQL的基本架构么？你能在纸上给我大致画出这个示意图么？

![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbmryvendlj308m0goq4e.jpg)

##### 2.连接器是什么

我们要进行查询，第一步就是先去链接数据库，那这个时候就是连接器跟我们对接。

他负责跟客户端建立链接、获取权限、维持和管理连接。

链接的时候会经过TCP握手，然后身份验证，然后我们输入用户名密码就好了。

验证ok后，我们就连上了这个MySQL服务了，但是这个时候我们处于空闲状态。

**怎么查看空闲连接列表？**

**show processlist**，下图就是我在自己的数据库表执行命令的结果，其中的Command列显示为Sleep的这一行，就表示现在系统里面有一个空闲连接。

![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbmizyzijbj30vq04utb4.jpg)


这里需要注意的是，我们数据库的客户端太久没响应，连接器就会自动断开了，这个时间参数是wait_timeout控制住的，默认时长为8小时。

断开后重连的时候会报错，如果你想再继续操作，你就需要重连了。

这个有个我看过的书本的案例：

```
一个在政府里的朋友说，他们的系统很奇怪，每天早上都得重启一下应用程序，否则就提示连接数据库失败，他们都不知道该怎么办。
我分析说，按照这个错误提示，应该就是连接时间过长了，断开了连接。数据库默认的超时时间是8小时，而你们平时六点下班，下班之后系统就没有人用了，等到第二天早上九点甚至十点才上班，这中间的时间已经超过10个小时了，数据库的连接肯定就会断开了。是的，就是超出了超时时间，然后写代码的人也没注意到这个细节，所以才会出现这个问题。把超时时间改得长一点，问题就解决了。
```

这种参数其实我们平时不一定能接触到，但是真的遇到问题的时候，知道每个参数的大概用法，不至于让你变成无头苍蝇。那除了重新链接，还有别的方式么？因为建立链接还是比较麻烦的。**使用长连接。**

但是这里有个缺点，使用长连接之后，内存会飙得很快，我们知道MySQL在执行过程中临时使用的内存是管理在连接对象里面的。

只有在链接断开的时候才能得到释放，那如果一直使用长连接，那就会导致OOM（Out Of Memory），会导致MySQL重启，在JVM里面就会导致**频繁的Full GC**。

那你会怎么解决？
我一般会定期断开长连接，使用一段时间后，或者程序里面判断执行过一个占用内存比较大的查询后就断开连接，需要的时候重连就好了。

还有别的方法么？你这种感觉不优雅呀小老弟。
执行比较大的一个查询后，执行mysql_reset_connection可以重新初始化连接资源。这个过程相比上面一种会好点，不需要重连，但是会初始化连接的状态。

##### 3.查询缓存是什么

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。大家是不是好奇同一条语句在MySQL执行两次，第一次和后面的时间是不一样的，后者明显快一些，这就是因为缓存的存在。

​		MySQL跟Redis一样，只要是你之前执行过的语句，**都会在内存里面用key-value形式存储着**。查询的时候就会拿着语句先去缓存中查询，如果能够命中就返回缓存的value，如果不命中就执行后面的阶段。但是我还是不喜欢用缓存，**因为缓存弊大于利**。哦？此话怎讲？**缓存的失效很容易**，只要对表有任何的更新，这个表的所有查询缓存就会全部被清空，就会出现缓存还没使用，就直接被清空了，或者积累了很多缓存准备用来着，但是一个更新打回原形。这就导致查询的命中率低的可怕，只有那种**只查询不更新的表适用缓存**，但是这样的表往往很少存在，一般都是什么**配置表**之类的。

那我们查询的时候不想用缓存一般都是怎么操作的，或者是用缓存又怎么操作？可以显示调用，把query_cache_type设置成为DEMAND，这样SQL默认不适用缓存，想用缓存就用SQL_CACHE。

有个小技巧就是，我们之前开发的时候，都会去库里看看sql执行时间，但是可能是有缓存的，一般我们就在sql前面使用SQL_NO_CACHE就可以知道真正的查询时间了。

```mysql
 select SQL_NO_CACHE * from B
```


缓存在MySQL8.0之后就取消了，所以大家现在应该不需要太关注这个问题，主要是我之前用的版本都不高，所以缓存一直有，在《高性能MySQL》书中也看到了一些关于缓存的介绍，就想起来给大家也提一下了。

##### **4.分析器是什么**

在缓存没有命中的情况下，就开始执行语句了，你写的语句有没有语法错误，这是接下来MySQL比较关心的点。

那他会怎么做呢？会先做**词法分析**，你的语句有这么多单词、空格，MySQL就需要识别每个字符串所代表的是什么，是关键字，还是表名，还是列名等等。然后就开始**语法分析**，根据词法分析的结果，语法分析会判断你sql的对错，错了会提醒你的，并且会提示你哪里错了。

##### 5.优化器和执行器是什么

主要是优化什么呢？
优化就比较简单了，因为我们建立表可能会建立很多索引，优化有一步就是要**确认使用哪个索引**，比如使用你的主键索引，联合索引还是什么索引更好。

还有就是**对执行顺序进行优化**，条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定选用哪种方案。

最后就是执行了，**执行就交给执行器去做**。

第一步可能就是**权限的判断**，其实这里我不确定的一个点就是，我接触的公司很多都是**自研的线上查询系统**，我们是不能用Navicat直连线上库，只能去网页操作，那表的权限是在MySQL层做的，还是系统做的，我猜应该是系统层做的，**MySQL可能默认就全开放了**，只是我们 不知道ip。

执行的时候，就**一行一行的去判断是否满足条件**，有索引的执行起来可能就好点，一行行的判断就像是接口都提前在引擎定义好了，所以他比较快。

数据库的慢日志有个**rows_examined字段**，扫描多少行可以看到，还有explain也可以看到执行计划，我们扫描了多少行。可以小伙子，基础大致框架还是了解得很清楚的，我们下次深入了解下，**索引和部分机制**。



#### MySQL索引结构

##### 1.索引数据结构

###### 1.平衡二叉树:

平衡二叉树在数据结构中属于比较好理解的部分，按照键值的大小将索引存储在二叉树合适的位置，具体的存储方法就和平衡二叉树的存储是一样的。需要注意左右子树的高度差，进行二叉树的旋转保证二叉树的平衡。



###### 2.B树：

B树的每个结点内部都要存储一个指向关键字代表的具体数据的指针，因为每个盘块的大小是固定的，这样使得每个结点的度相对应较小，如果每个磁盘只存储对应的主键值或者只存储指向具体数据的指针这样可以解决存储空间。B树的存储方式很接近二叉树，这样会导致有些数据的查找较慢，比如有些数据的深度较大。采用B+树的方式使得查找更加稳定。



###### 3.B+树：

B+树很好的弥补了B树的一些缺点提高了的查找效率和存储效率。



###### 4.Hash索引：

和数据结构中的hash查找类似，通过计算关键字的hash值查找该数据对应的地址，可以理解为通过hash值并对hash值进行相应的处理确定数据的存储位置，如果发生数据冲突，解决的办法为链地址法。



##### 2.MySQL存储引擎

###### 1.InnoDB(聚簇索引)

InnoDB的一个数据表中，它的索引文件和数据文件是同一个，也就是说，在查询时只要找到了索引就找到了数据文件。在InnoDB中及存储主键索引值，有存储行数据，叫做聚簇索引 。

聚簇索引会将磁盘数据按照一列或者多列的值进行排序，通过是按照主键内一列的值进行排序的。聚簇索引的特点是存储的顺序和索引的顺序一致，一张表中只存在一个聚簇索引。



###### 2.MyIsam（非聚簇索引）

非聚簇索引也就是数据和索引分开存储的



###### 3.联合索引 

最左匹配原则，按照联合索引进行查找的原则是，查找字段的关键字中必须按照索引设定顺序出现才能按照索引进行查找。也就是说查找的关键字序列中出现了某一个关键字，但是该关键字在索引中的前一个关键字并未出现，则不能按照索引查找。

比如我为一个字段设置了ABC三个关键字为联合索引。那么当我的查询条件出现了BC而没有写出A，那么将无法使用的索引的方式进行查询。






#### MySQL索引结构面试问题

##### 1.前言

写数据库，我第一时间就想到了MySQL、Oracle、索引、存储过程、查询优化等等。

不知道大家是不是跟我想得一样，我最想写的是索引，为啥呢？

以下这个面试场景，不知道大家熟悉不熟悉：

面试官：数据库有几千万的数据，查询又很慢我们怎么办？

面试者：加索引。

面试官：那索引有哪些数据类型？索引是怎么样的一种结构？哪些字段又适合索引呢？B+的优点？聚合索引和非聚合索引的区别？为什么说索引会降低插入、删除、修改等维护任务的速度？……..


##### 2.索引结构

> 我看你简历上写到了熟悉MySQL数据库以及索引的相关知识，我们就从索引开始，索引有哪些数据结构？

**Hash、B+**

大家去设计索引的时候，会发现索引类型是可以选择的。

![img](https://tva1.sinaimg.cn/large/0082zybply1gbyctrt3swj30sy05wac6.jpg)

> 为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？

###### **Hash**

注意字段值所对应的数组下标是哈希算法随机算出来的，所以可能**出现哈希冲突。**

那么对于这样一个索引结构，现在来执行下面的sql语句：

select * from sanguo where name='鸡蛋'

可以直接对‘鸡蛋’按哈希算法算出来一个数组下标，然后可以直接从数据中取出数据并拿到所对应那一行数据的地址，进而查询那一行数据， 那么如果现在执行下面的sql语句：

select * from sanguo where name>'鸡蛋'

则无能为力，因为哈希表的特点就是可以快速的精确查询，但是**不支持范围查询**。

如果**做成了索引，那速度也是很慢的，要全部扫描**。

1.问个题外话，那Hash表在哪些场景比较适合？
等值查询的场景，就只有**KV（Key，Value）**的情况，例如**Redis、Memcached**等这些NoSQL的中间件。

2.你说的是无序的Hash表，那有没有有序的数据结构？
**有序数组**，它就比较优秀了呀，它在等值查询的和范围查询的时候都很Nice。

3.那有序数组完全没有缺点么？
不是的，**有序的适合静态数据**，因为如果我们新增、删除、修改数据的时候就会改变他的结构。

比如你新增一个，那在你新增的位置后面所有的节点都会后移，成本很高。

4.那照你这么说他根本就不优秀啊，特点也没地方放。
此言差矣，可以用来做**静态存储引擎**啊，用来**保存静态数据**，例如你2019年的支付宝账单，2019年的淘宝购物记录等等都是很合适的，都是不会变动的历史数据。

###### B+树

二叉树是有序的，所以是支持范围查询的。

![img](https://tva1.sinaimg.cn/large/0082zybply1gbrmizw7s9g30ao07qtbx.gif)

但是他的**时间复杂度是O(log(N))**，为了维持这个时间复杂度，**更新的时间复杂度也得是O(log(N))**，那就得保持这棵树是完全平衡二叉树了。怎么听你一说，平衡二叉树用来做索引还不错呢？此言差矣，索引也不只是在内存里面存储的，还是要落盘持久化的，可以看到图中才这么一点数据，如果数据多了，**树高会很高**，查询的成本就会随着树高的增加而增加。为了节约成本很多公司的磁盘还是采用的机械硬盘，这样一次千万级别的查询差不多就要10秒了，这谁顶得住啊？

**如果用B树呢？同理来看看B树的结构：**

**![img](https://tva1.sinaimg.cn/large/0082zybply1gbrmhi9rosg30ag02sdh4.gif)**

可以发现同样的元素，B树的表示要**比完全平衡二叉树要“矮”**，原因在于B树中的**一个节点可以存储多个元素。**B树其实就已经是一个不错的数据结构，用来做索引效果还是不错的。

> 那为啥没用B树，而用了B+树？

一样先看一下B+的结构：

![img](https://tva1.sinaimg.cn/large/0082zybply1gbrmh3b29og309m04i43b.gif)

我们可以发现同样的元素，B+树的表示要比B树要“胖”，原因在于**B+树中的非叶子节点会冗余一份在叶子节点中**，并且叶子节点之间用指针相连。

**那么B+树到底有什么优势呢？**

其实很简单，我们看一下上面的数据结构，最开始的Hash不支持范围查询，二叉树树高很高，只有B树跟B+有的一比。B树一个节点**可以存储多个元素**，相对于完全平衡二叉树整体的树高降低了，**磁盘IO效率提高**了。

而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的**好处是为了提高范围查找的效率**。

提高了的原因也无非是会有指针指向下一个节点的叶子节点。

**小结：到这里可以总结出来，Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。**

那么，一个B+树的节点中到底存多少个元素最合适你有了解过么？
额这个这个？卧*有点懵逼呀。过了一会还是没想出，只能老实交代：这个不是很了解咳咳。

你可以换个角度来思考**B+树中一个节点到底多大合适**？

**B+树中一个节点为一页或页的倍数最为合适**。为啥？
因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。

如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。

所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。

你提到了页的概念，能跟我简单说一下么？首先Mysql的基本存储结构是页(记录都存在页里边)：

![img](https://tva1.sinaimg.cn/large/0082zybply1gbyawfuy6oj310s0tuqe2.jpg)

- 各个数据页可以组成一个双向链表

- 而每个数据页中的记录又可以组成**一个单向链表**

- 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

- 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

    所以说，如果我们写 select * from user where username='Tom'这样没有进行任何优化的sql语句，默认会这样做：定位到记录**所在的页**，需要遍历双向链表，找到所在的页，从所在的页内中**查找相应的记录**，由于不是根据主键查询，只能遍历所在页的单链表了，很明显，在数据量很大的情况下这样查找会很慢！看起来跟回表有点点像。

###### **回表**

回表大概就是我们有个主键为ID的索引，和一个普通name字段的索引，我们在普通字段上搜索：

select * from table where name = '丙丙'

执行的流程是先查询到name索引上的“丙丙”，然后找到他的id是2，最后去主键索引，找到id为2对应的值。

回到**主键索引树搜索**的过程，就是回表。不过也有方法避免回表，那就是**覆盖索引**。

###### **覆盖索引**

这个其实比较好理解，刚才我们是 select * ，查询所有的，我们如果只查询ID那，其实在Name字段的索引上就已经有了，那就不需要回表了。覆盖索引可以**减少树的搜索次数**，提升性能，他也是我们在实际开发过程中经常用来优化查询效率的手段。很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率。

###### **索引的最左匹配原则**

最左匹配原则：索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。因此，列的排列顺序决定了可命中索引的列数。例子：

如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)



##### 3.总结

索引在数据库中是一个非常重要的知识点！

上面谈的其实就是索引最基本的东西，N叉树，跳表、LSM我都没讲，同时要创建出好的索引要顾及到很多的方面：

**最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，**MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配**。
尽量选择**区分度高**的列作为索引，区分度的公式是 **COUNT(DISTINCT col)/COUNT(*)**。表示**字段不重复的比率**，比率越大我们扫描的记录数就越少。
**索引列不能参与计算，尽量保持列“干净”**。比如， FROM_UNIXTIME(create_time)='2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time=UNIX_TIMESTAMP('2016-06-06')。
尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引(经指正，在MySQL5.0以后的版本中，有“合并索引”的策略，翻看了《高性能MySQL 第三版》，书作者认为：还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略)。“合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来





#### MySQL引擎与语法

##### 1.InnoDB和MyISAM的区别

mysql支持很多表类型的表（即存储引擎），如myisam、innodb、memory、archive、example等。每种存储引擎都有自己的优点和缺点，充分的理解每种存储引擎，有助于合理的使用它们。有人认为在同一个数据库中使用多种存储引擎很影响性能，其实这是一种十分错误的想法。实际上，除非是非常简单的数据库，否则的话，只使用一种存储引擎，对应用程序的性能来说是一个十分糟糕的行为。对数据库了解的人会根据每张表的作用不同来选择适当的存储引擎，这才是正确的做法。mysql的存储引擎很多，但是在工作中运用最多的存储引擎有两个，一个是InnoDB,一个是MyISAM。这里就聊聊这两个存储引擎，并比较下两者之间的区别。

###### **MyISAM**

MyISAM现在为mysql的**默认存储引擎**，如果在建表的时候，没有指定表类型，mysql就会默认使用MyISAM。MyISAM有一个很多人认为很重要，然而我却觉得没什么卵用的特性，那就是MyISAM表示**独立于操作系统之外**的。通俗点说就是你**可以很轻松的将MyISAM表从windows移植到linux或者从linux移植到windows**。这确实是个优点，可是哪个技术主管会有在决定用了一种操作系统一段时间后又要换服务器的操作系统的脑残行为，所有我认为这个优点没有什么实际的意义。

MyISAM存储引擎是mysql组件中非常重要的一部分，在mysql中可以创建3种MyISAM格式的表——静态、动态和压缩。格式不需要单独指定，mysql会根据表结构自动选择最合适的格式。

1、**MyISAM静态**

如果表的每个字段的数据类型的定义都是使用静态的（如char），mysql就会自动使用静态MyISAM格式，这种类型格式的表的性能是很高的，也就是查询更新用的时间很少，但要知道这是在牺牲空间为代价。因为每一列都要分配最大的空间，即使有部分空间没有用到，这就使得静态的表所占的空间会比较大。

2、**MyISAM动态**

如果表的每个字段的数据类型的定义都是使用动态的（如varchar），mysql就会自动使用动态MyISAM格式，这种类型格式的表的性能会有所下降，但是它的空间占有要比静态的少很多。

3、**MyISAM压缩**

如果有一张表在设计之初只赋予了它读的使命，就可以用MyISAM压缩表，在相同的配置下，它的性能是最快的。



###### **InnoDB**

InnoDB是一个事务型存储引擎，它默认支持事务。因此，在对数据完整度有较高要求的项目中，都是采用InnoDB作为存储引擎，比如跟银行相关的项目。InnoDB还引入行级锁定。其他表类型都是全表锁定，意思就是说，在一个用户要修改一张表中，自己那一行的某个信息的时候，数据库会先锁定整张表，其他用户对这张表无法进行操作，这就是全表锁定。行级锁定就不一样了，只锁定自己要修改的那一行的，也就是说其他人对表还可以进行操作，只是不能操作被锁定的那一行的数据了。好处显而易见，在速度上更快了，特别适合处理多重并发的更新请求。InnoDB还引入了外键约束。

###### 两种引擎的主要区别

**MyISAM：**

每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。**.frm文件存储表定义**。数据文件的**扩展名为.MYD (MYData)**。MyISAM表格可以被压缩，而且它们支持全文搜索。**不支持事务**，而**且也不支持外键**。如果事务回滚将造成不完全回滚，**不具有原子性**。在进行updata时进行表锁，**并发量相对较小**。如果执行大量的SELECT，**MyISAM是更好的选择**。

MyISAM的索引和数据是分开的，并且**索引是有压缩的**，内存使用率就对应提高了不少。能加载更多索引，而Innodb是**索引和数据是紧密捆绑的**，没有使用压缩从而会造成**Innodb比MyISAM体积庞大不小**。MyISAM**缓存在内存的是索引**，不是数据。而InnoDB**缓存在内存的是数据**，相对来说，服务器内存越大，InnoDB发挥的优势越大。

**优点：**查询数据相对较快，适合**大量的select**，可以**全文索引**。

**缺点：**不支持事务，不支持外键，**并发量较小**，不适合大量update

**InnoDB：**

这种类型是事务安全的。它与BDB类型具有相同的特性,它们还**支持外键**。具有比BDB还丰富的特性,因此如果需要一个事务安全的存储引擎，建议使用它。**在update时表进行行锁，并发量相对较大**。如果你的数据**执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表**。

**优点：**支持事务，支持外键，并发量较大，适合大量update

**缺点：**查询数据相对较快，**不适合大量的select**

对于支持事务的InnoDB类型的表，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事务（即使autocommit打开也可以），将大大提高性能。

**基本的差别为**：MyISAM类型**不支持事务处理等高级处理**，而InnoDB类型支持。MyISAM类型的表强调的是**性能**，其执行数度比InnoDB类型**更快**，而InnoDB提供**事务支持**以及**外键**等高级数据库功能。



###### **具体实现细节的差别**

- 1.InnoDB不支持FULLTEXT类型的索引。
- 2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数 即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。
- 3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
- 4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
- 5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的 InnoDB特性（例如外键）的表不适用。

另外，InnoDB表的**行锁也不是绝对的**，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，**InnoDB表同样会锁全表**，例如update table set num=1 where name like "%aaa%"。任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。



###### **MyISAM与InnoDB如何选择**

MYISAM和INNODB是Mysql数据库提供的两种存储引擎。两者的优劣可谓是各有千秋。INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MYISAM不支持。MYISAM的性能更优，占用的存储空间少。所以，选择何种存储引擎，视具体应用而定。

如果你的应用程序**一定要使用事务，毫无疑问你要选择INNODB引擎**。但要注意，INNODB的行级锁是有条件的。在**where条件没有使用主键时，照样会锁全表**。比如DELETE FROM mytable这样的删除语句。

如果你的应用程序对查询性能要求较高，就要使用MYISAM了。**MYISAM索引和数据是分开的**，而且其索引是压缩的，可以更好地利用内存。所以它的**查询性能明显优于INNODB**。压缩后的索引也能节约一些磁盘空间。MYISAM拥有**全文索引的功能**，这可以极大地优化LIKE查询的效率。

有人说MYISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如**分表分库**，而不是**单纯地依赖存储引擎**。

**其他一些说法：**现在一般都是选用innodb了，主要是myisam的全表锁，读写串行问题，并发效率锁表，效率低myisam对于读写密集型应用一般是不会去选用的。

**关于Mysql数据库默认的存储引擎**：

MyISAM和InnoDB是MySQL的两种存储引擎。如果是默认安装，那就应该是InnoDB，你可以在my.ini文件中找到default-storage-engine=INNODB；当然你可以在建表时指定相应的存储引擎。通过show create table xx 可以看见相应信息。



##### 2.ON 与 WHERE 的区别

**前言**

很多同学在学习 Mysql 表关联的时候弄不清 `ON` 与 `WHERE` 的区别，不知道条件应该写在 `ON` 里面还是 `WHERE` 里面，作者在工作的时候也入过坑，总觉得条件写在哪里查询结果都是一样的，最后出错坏了事，差点惹了大祸。所以今天简单易懂的总结一下他们的区别，大家共同学习。

**准备工作**

我们先准备两个表，并造一些数据：

```sql
-- t1
create table t1
(
    id bigint default '0' not null comment '主键id',
    name char(100) default '' not null comment '姓名',
    age int default '0' not null
);
-- t2
create table t2
(
    id bigint default '0' not null comment '主键id',
    goals int default '0' not null comment '进球数',
    matches int default '0' not null comment '比赛编号'
);
```

**探究**

**口诀：先执行 `ON`，后执行 `WHERE`；`ON` 是建立关联关系，`WHERE` 是对关联关系的筛选**。记住这句话就可以准确地判断查询结果了，我们通过两个 sql 来进行分析：

```sql
SELECT t1.id, t1.name, t1.age FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE matches = 2; -- 条件放在 WHERE
SELECT t1.id, t1.name, t1.age FROM t1 LEFT JOIN t2 ON t1.id = t2.id AND matches = 2; -- 条件放在 ON
```

执行第一个 sql 时，前提是 `LEFT JOIN`，所以左边的数据在创建关联关系时会保留，根据口诀，先执行 `ON` 建立关联关系，然后通过 `WHERE` 筛选。

**多表查询语法结构：**
table_reference {[INNER] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr

在多表查询时，ON和where都表示筛选条件，**on先执行**，**where后执行**。
**区别：**外连接时，on条件是在**生成临时表时使用的条件**，它不管on中的条件是否为真，**都会返回左边表中的记录**。而where条件是在临时表生成好后，**再对临时表进行过滤的条件**。











#### MySQL常见查询-leetCode

##### [1. 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/)

编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。

+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+

**思路：**

首先先将数据去重：SELECT DISTINCT Salary FROM Employee
再将是数据按薪水降序排除：SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC
分页的思想是一页一条数据，第二高的薪水则在第二页：SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1, 1
考虑到极端情况：没有第二薪水则为空，使用ifnull判断：
SELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1, 1),null) AS SecondHighestSalary
分页的其他使用：offset
SQL查询语句中的 limit 与 offset 的区别：
limit y 分句表示: 读取 y 条数据
limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据
limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据

**解法：**

①	select Salary as SecondHighestSalary from Employee order by Salary desc limit 1 offset 1

②	select ifNull((select distinct salary from Employee order by Salary Desc limit 1,1),null ) as  SecondHighestSalary;

③	SELECT DISTINCT  Salary AS SecondHighestSalary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1

##### 2.[第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/)

编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+

**解答：**

CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT

BEGIN

  set N = N-1;

 RETURN (

   *# Write your MySQL query statement below.*

   select ifNull((select distinct Salary from Employee 

   order by Salary desc

   limit 1 offset N),null) as SecondHighestSalary 

 );

END



##### 3.[分数排名](https://leetcode-cn.com/problems/rank-scores/)

编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。

+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：

+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+

**解答**：

select a.Score as Score,

(select count(distinct b.Score) from Scores as b where b.Score>=a.Score) as Rank

from Scores as a

order by a.Score desc



##### 4.编写一个 SQL 查询，查找所有至少连续出现三次的数字。

编写一个 SQL 查询，查找所有至少连续出现三次的数字。

+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。

+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+



##### 5.[组合两个表](https://leetcode-cn.com/problems/combine-two-tables/)

表1: `Person`

```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```

表2: `Address`

```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

```
FirstName, LastName, City, State
```

**解答：**

考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。

select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId;

    注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。








