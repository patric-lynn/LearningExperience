### Java虚拟机

#### 1.走近Java虚拟机

##### 1.Java技术体系

​		从广义上讲，Clojure、JRuby、Groovy等运行于Java虚拟机上的语言及其相关的程序都 属于Java技术体系中的一员。如果仅从传统意义上来看，Sun官方所定义的Java技术体系包括以下几个组成部分:

- Java程序设计语言
- 各种硬件平台上的Java虚拟机
- Class文件格式
- Java API类库
- 来自商业机构和开源社区的第三方Java类库

​		以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域来划分，或者说按照Java技术关注的重点业务领域来划分，**Java技术体系可以分为4个平台**，分别为:

- Java Card : 支持一些Java小程序( Applets ) 运行在小内存设备(如智能卡)上的平台。
- Java ME ( Micro Edition ) : 支持Java程序运行在移动终端(手机、 PDA ) 上的平台，对 Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
- Java SE ( Standard E d i t i o n ) : 支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE。
- Java EE ( Enterprise Edition): 支持使用多层架构的企业应用(如ERP、CRM应用)的 Java平台，除了提供Java SE API外 ，还对其做了大量的扩充- 并提供了相关的部署支持，这 个版本以前称为J2EE。



##### 2.展望Java技术的未来

​		在2005年，Java语言诞生10周年的SunOne技术大会上，Java语言之父James Gosling做了一场题为"Java技术下一个十年"的演讲。笔者不具备James Gosling博士那样高屋建瓴的视角 ，这里仅从Java平台中几个新生的但已经开始展现出蓬勃之势的技术发展点来看一下后续 1〜2个JDK版本内的一些很有希望的技术重点。

​		模块化，模块化是解决应用系统与技术平台越来越复杂，越来越庞大而产生的一系列问题的一个重要途径。最近几年OSGI技术的迅速发展正说明了通过模块化实现按需部署，降低复杂性和维护成本的需求是相当迫切的。 混合语言，今年原来越多语言运行在Java这个平台上，例如Groovy，JRuby，Clojure等。试想一下，在一个项目中，并行处理使用Clojure语言编写，展示层使用Jruby或Rails，中间层则是Java，每个应用层将使用不同的语言来完成，而且，接口对每一层的开发都是透明的，各种语言之间的交互不存在任何困难，因为它们最终都运行在一个虚拟机上。 多核并行，引入java.util.concurren包，能够轻松地利用多个CPU核心提供的计算资源完成一个复杂的计算任务。 进一步丰富语法，JDK不断升级改进语法。 随着主流的CPU开始支持64位架构，JAVA虚拟机也在很早之前就推出了支持64位系统的版本。



##### 3.解释器与JIT编译器

​		首先我们先来了解一下运行在虚拟机之上的解释器与JIT编译器。

​		当我们的虚拟机在运行一个java程序的时候，它可以采用两种方式来运行这个java程序：

-   **采用解释器的形式**，也就是说，在运行.class运行的时候，**解释器一边把.class文件翻译成本地机器码，一边执行**。显然这种一边解释翻译一边执行发方式，可以**使我们立即启动和执行程序，省去编译的时间**。不过由于需要一遍解释翻译，会让程序的**执行速度比较慢**。 
-   **采用JIT编译器的方式**：注意，JIT编译器是把.class文件翻译成本地机器码，而javac编译器是把.java源文件编译成.class文件。如果采用JIT编译器的方式则是在启动运行一个程序的时候，先把.class文件全部翻译成本地机器码，然后再来执行，显然，这种方式在执行的时候**由于不用对.clasa文件进行翻译，所以执行的速度会比较快**。当然，代价就是我们需要花销一定的时间来把字节码翻译成本地机器码。这样，程序在启动的时候，会有更多的延迟。 这两种方式可以说是各有优势，虚拟机(特指HotSpot虚拟机)在执行的时候，一般会采用两种方式结合的策略。

​		也就是说，在程序执行的时候，有些代码采用解释器的方式，有些代码采用编译器，称之为**即时编译**。一般我们会对热点代码采用编译器的方式。







#### 2.Java虚拟机概述与内存结构

​		Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的"高墙"，墙外面的人想进去，墙里面的人却想出来。

##### 1.概述

​		对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有**最高权力的“皇帝”又是从事最基础工作的“劳动人民”**——既拥有每一个对象的“所有权”，又担负着每一个对象生命**开始到终结的维护责任**。 对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么**排查错误将会成为一项异常艰难的工作**。



##### 2.运行时数据区域

<img src="file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306125246331.png?lastModify=1584461517" alt="image-20200306125246331" style="zoom:50%;" />

​		JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

- **Class loader(类装载)**：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。
- **Execution engine（执行引擎）**：执行classes中的指令。
- **Native Interface(本地接口)**：与native libraries交互，是**其它编程语言交互的接口**。
- **Runtime data area(运行时数据区域)**：这就是我们常说的JVM的内存。

​		**Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域**。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所**管理的内存**被划分为如下几个区域：

<img src="file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306125440890.png?lastModify=1584461517" alt="image-20200306125440890" style="zoom:27%;" />

<img src="file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306125516358.png?lastModify=1584461517" alt="image-20200306125516358" style="zoom:38%;" />

###### 1.程序计数器（线程私有）

​		程序计数器是一块较小的内存区域，可以看做是**当前线程所执行的字节码的行号指示器**。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。「**属于线程私有的内存区域**」

- 当前线程所执行的字节码行号指示器。
- 每个线程都有一个**自己的PC计数器**。
- 线程**私有的**，生命周期与线程相同，随JVM启动而生，JVM关闭而死。
- 线程执行Java方法时，记录其**正在执行的虚拟机字节码指令地址**。
- 线程执行Native方法时，**计数器记录为空**(Undefined)。
- 唯一在Java虚拟机规范中**没有规定任何OutOfMemoryError情况区域**。



###### 2.Java虚拟机栈（线程私有）

​		线程私有内存空间，它的生命周期**和线程相同**。线程执行期间，每个方法被执行时，都会创建一个**栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息**。每个方法从被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。「属于线程私有的内存区域」。下面依次解释栈帧里的四种组成元素的具体结构和功能：

**2.1 局部变量表**

​		**局部变量表**是 Java 虚拟机栈的一部分，是一组变量值的存储空间，用于存储**方法参数和局部变量**。 在 Class 文件的方法表的 Code 属性的 max_locals 指定了该方法所需局部变量表的**最大容量**。

​		局部变量表在编译期间分配内存空间，可以存放编译期的各种变量类型：

- **基本数据类型** ：boolean, byte, char, short, int, float, long, double等8种；
- **对象引用类型** ：reference，指向对象起始地址的**引用指针**；不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置
- **返回地址类型** ：returnAddress，返回地址的类型。指向了一条字节码指令的地址

​		**变量槽**(Variable Slot)：变量槽是局部变量表的最小单位，规定大小为32位。对于64位的long和double变量而言，虚拟机会为其分配两个连续的Slot空间。

**2.2 操作数栈**

​		操作数栈（Operand Stack）也常称为**操作栈**，是一个后入先出栈。在 Class 文件的 Code 属性的 max_stacks 指定了执行过程中最大的栈深度。Java虚拟机的解释执行引擎被称为**基于栈的执行引擎** ，其中所指的栈就是指－操作数栈。

- 和局部变量表一样，操作数栈也是一个**以32字长为单位的数组**。
- 虚拟机在操作数栈中**可存储的数据类型**：int、long、float、double、reference和returnType等类型 (对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int)。
- 和局部变量表不同的是，它**不是通过索引来访问**，而是通过标准的栈操作 — 压栈和出栈来访问。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。

虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。

**2.3 动态链接**

​		每个栈帧都包含一个指向运行时常量池中所属的方法引用，持有这个引用是为了支持方法调用过程中的动态链接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用：

- **静态解析**：一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等）。
- **动态解析**：另一部分将在每一次的运行期间转化为直接引用，称为动态链接。

**2.4 方法返回地址**

​		当一个方法开始执行以后，只有两种方法可以退出当前方法：

- 正常返回：当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口(Normal Method Invocation Completion)，一般来说，调用者的PC计数器可以作为返回地址。

- 异常返回：当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口(Abrupt Method Invocation Completion)，返回地址要通过异常处理器表来确定。

    当一个方法返回时，可能依次进行以下3个操作：

- 恢复上层方法的局部变量表和操作数栈。

- 把返回值压入调用者栈帧的操作数栈。

- 将PC计数器的值指向下一条方法指令位置。

**2.5 小结**

​		注意：在Java虚拟机规范中，对这个区域规定了两种异常。 其一：如果当前线程请求的栈深度大于虚拟机栈所允许的深度，将会抛出 **StackOverflowError 异常**（在虚拟机栈不允许动态扩展的情况下）； 其二：如果扩展时无法申请到足够的内存空间，就会抛出 **OutOfMemoryError 异常**。



###### 3.本地方法栈（线程私有）

​		本地方法栈和Java虚拟机栈发挥的作用非常相似，主要区别是Java虚拟机栈执行的是Java方法服务，而本地方法栈执行**Native方法服务**(通常用C编写)。

​		有些虚拟机发行版本(譬如Sun HotSpot虚拟机)直接将本地方法栈和Java虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会抛出**StackOverflowError**和**OutOfMemoryError**异常。



###### 4.Java堆（全局共享）

​		对大多数应用而言，Java 堆是虚拟机所管理的**内存中最大的一块**，是被**所有线程共享**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一作用就是**存放对象实例**，几乎所有的**对象实例**都是在这里分配的（不绝对，在虚拟机的优化策略下，也会存在**栈上分配、标量替换**的情况，后面的章节会详细介绍）。

​		**Java 堆是 GC 回收的主要区域**，因此很多时候也被称为 **GC 堆**。

​		从内存回收的角度看，由于现在收集器基本都采用**分代收集算法**，所以在Java堆被划分成两个不同的区域：**新生代** (Young Generation) 、**老年代** (Old Generation) 。

​		**新生代** (Young) 又被划分为两个区域：一个**Eden区**和两个**Survivor区** - From Survivor区和To Survivor区。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，记你一步划分的目的是为了使JVM能够更好的管理堆内存中的对象，包括内存的分配以及回收。简要归纳：新的对象分配是首先放在**年轻代 (Young Generation) 的Eden区**，Survivor区作为Eden区和Old区的缓冲，在Survivor区的对象经历若干次收集仍然存活的，就会被转移到老年代Old中。

​		从内存回收的角度看，线程共享的 Java 堆可能划分出多个线程**私有的分配缓冲区**（Thread Local Allocation Buffer，TLAB）。「属于线程共享的内存区域」



###### 5.方法区（全局共享）

方法区和Java堆一样，为多个线程共享，它用于存储**类信息、常量、静态常量和即时编译后的代码等数据**。Non-Heap（非堆）「属于线程共享的内存区域」

**运行时常量池**

**运行时常量池是方法区的一部分**。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译期生成的**各种字面常量和符号引用**，这部分内容会在类加载后进入方法区的运行时常量池。

- HotSpot虚拟机中，将**方法区称为“永久代”**，本质上两者并不等价，仅仅是因为HotSpot虚拟机把GC分代收集扩展至方法区。

- JDK 7的HotSpot中，已经将原本**存放于永久代中的字符串常量池移出**。

- 根据虚拟机规范的规定，当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。当常量池无法再申请到内存时也会抛出OutOfMemoryError异常。

- JDK 8的HotSpot中，**已经将永久代废除**，用**元数据实现了方法区**。元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是**使用本地内存**。理论上取决于32位/64位系统**可虚拟的内存大小**。可见也不是无限制的，需要配置参数。

  ​    

###### 6.直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。Java 中的 NIO 可以使用 Native 函数**直接分配堆外内存**，通常直接内存的速度会优于Java堆内存，然后通过一个存储在 Java 堆中的 DiectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景显著提高性能，对于读写频繁、性能要求高的场景，可以**考虑使用直接内存**，因为避免了在 Java 堆和 Native 堆中来回复制数据。直接内存不受 Java 堆大小的限制。







##### HotSpot虚拟机对象探秘

##### **1.对象的创建**

说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：

​       Header	             解释

- 使用new关键字	调用了构造函数
- 使用Class的newInstance方法	调用了构造函数
- 使用Constructor类的newInstance方法	调用了构造函数
- 使用clone方法	没有调用构造函数
- 使用反序列化	没有调用构造函数

​        虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。

###### 1.判断对象对应的类是否加载、链接、初始化

虚拟机接收到一条new指令时，首先会去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被类加载器加载、链接和初始化过。如果没有则先执行相应的类加载过程。

###### 2.为对象分配内存

类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：

- 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。
- 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 ![image-20200306133742019](file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306133742019.png?lastModify=1584461517)

###### 3.处理并发安全问题

对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：

- 对分配内存空间的动作进行**同步处理**（采用 CAS + 失败重试来保障更新操作的原子性）；
- 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。

![image-20200306133910751](file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306133910751.png?lastModify=1584461517)

###### 4.初始化分配到的内存空间

内存分配完后，虚拟机要将分配到的内存空间初始化为零值（不包括对象头）。如果使用了 TLAB，这一步会提前到 TLAB 分配时进行。这一步保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。

###### 5.设置对象的对象头

接下来设置对象头（Object Header）信息，包括对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中。

###### 6.执行init方法进行初始化

执行init方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就被创建了出来。





##### 2.对象的内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

###### 对象头

在HotSpot虚拟机中，对象头有两部分信息组成：**运行时数据 和 类型指针**，如果是数组对象，还有一个保存数组长度的空间。

**Mark Word（运行时数据）**：用于存储对象自身运行时的数据，如哈希码（hashCode）、GC分带年龄、线程持有的锁、偏向线程ID 等信息。在32位系统占4字节，在64位系统中占8字节；

HotSpot虚拟机对象头Mark Word在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示： ![image-20200306134319415](file:///Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306134319415.png?lastModify=1584461517)



###### 实例数据

实例数据 是对象真正存储的有效信息，无论是从父类继承下来的还是该类自身的，都需要记录下来，而这部分的存储顺序受虚拟机的分配策略和定义的顺序的影响。

**默认分配策略**：

long/double -> int/float -> short/char -> byte/boolean -> reference 如果设置了-XX:FieldsAllocationStyle=0（默认是1），那么引用类型数据就会优先分配存储空间：

reference -> long/double -> int/float -> short/char -> byte/boolean 

**结论**：

分配策略总是按照字节大小由大到小的顺序排列，相同字节大小的放在一起。



###### **对齐填充**

无特殊含义，不是必须存在的，仅作为占位符。

HotSpot虚拟机要求每个对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（32位为1倍，64位为2倍），因此，当对象实例数据部分没有对齐的时候，就需要通过对齐填充来补全。





##### 3.对象的访问定位

Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。

- **指针**： 指向对象，代表一个**对象在内存中的起始地址**。
- **句柄**： 可以理解为指向指针的指针，**维护着对象的指针**。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。

###### 句柄访问

`Java`堆中划分出一块内存来作为**句柄池**，引用中存储对象的**句柄地址**，而句柄中包含了**对象实例数据**与**对象类型数据**各自的**具体地址**信息，具体构造如下图所示：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200306134612950-4461689.png" alt="image-20200306134612950" style="zoom:36%;" />

**优势**：引用中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变**句柄中**的**实例数据指针**，而**引用**本身不需要修改。

###### 直接指针

如果使用**直接指针**访问，**引用** 中存储的直接就是**对象地址**，那么`Java`堆对象内部的布局中就必须考虑如何放置访问**类型数据**的相关信息。

![image-20200306134708051](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200306134708051-4461689-6145871.png)

**优势**：速度更**快**，节省了**一次指针定位**的时间开销。由于对象的访问在`Java`中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

















#### 3.垃圾回收器与内存分配策略

##### 1.概述

​		说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当作Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

​       经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了"自动化"时代，那为什么我们还要去了解GC和内存分配？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些"自动化"的技术实施必要的监控和调节。



##### 2.对象状态监控

​		垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。

###### 1.引用计数法

​		Java 堆 中**每个具体对象（不是引用）都有一个引用计数器**。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1。当引用失效时，即一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。

**优点：**

​		引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。

**缺点：**

​		**难以检测出对象之间的循环引用**。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。



###### 2.可达性分析算法

​		可达性分析算法又叫**根搜索算法**，该算法的基本思想就是通过一系列称为「GC Roots」的对象作为起始点，从这些起始点开始往下搜索，搜索所走过的**路径称为引用链**，当一个对象到 GC Roots 对象之间没有任何引用链的时候（不可达），证明该对象是不可用的，于是就会被判定为可回收对象。

​		如下图所示: Object5、Object6、Object7 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307095606406-4461689.png" alt="image-20200307095606406" style="zoom:30%;" />

在 Java 中可作为 GC Roots 的对象包含以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象。

JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图。



###### 3.再谈引用

​		无论是通过引用计数器还是通过可达性分析来判断对象是否可以被回收都设计到「引用」的概念。在 Java 中，根据引用关系的强弱不一样，将引用类型划为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

**强引用**：Object obj = new Object()这种方式就是强引用，只要这种强引用存在，垃圾收集器就永远不会回收被引用的对象。

**软引用**：用来描述一些有用但非必须的对象。在 OOM 之前垃圾收集器会把这些被软引用的对象列入回收范围进行二次回收。如果本次回收之后还是内存不足才会触发 OOM。在 Java 中使用 SoftReference 类来实现软引用。

**弱引用**：同软引用一样也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 Java 中使用 WeakReference 类来实现。

**虚引用**：是最弱的一种引用关系，一个对象是否有虚引用的存在完全不影响对象的生存时间，也无法通过虚引用来获取一个对象的实例。一个对象使用虚引用的唯一目的是为了在被垃圾收集器回收时收到一个系统通知。在 Java 中使用 PhantomReference 类来实现。



###### 4.生存还是死亡

一个对象是否应该在垃圾回收器在GC时回收，至少要经历**两次标记过程**。

**第一次标记**：如果对象在进行可达性分析后被判定为不可达对象，那么它将被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize() 方法。对象没有覆盖 finalize() 方法或者该对象的 finalize() 方法曾经被虚拟机调用过，则判定为没必要执行。

**finalize()第二次标记**：如果被判定为有必要执行 finalize() 方法，那么这个对象会被放置到一个 F-Queue 队列中，并在稍后由虚拟机自动创建的、低优先级的 Finalizer 线程去执行该对象的 finalize() 方法。但是虚拟机并不承诺会等待该方法结束，这样做是因为，如果一个对象的 finalize() 方法比较耗时或者发生了死循环，就可能导致 F-Queue 队列中的其他对象永远处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，如果对象要在 finalize() 中挽救自己，只要重新与 GC Roots 引用链关联上就可以了。这样在第二次标记时它将被移除「即将回收」的集合，如果对象在这个时候还没有逃脱，那么它基本上就真的被回收了。



###### 5.回收方法区

​		前面介绍过，方法区在 HotSpot 虚拟机中被**划分为永久代**。在 Java 虚拟机规范中没有要求方法区实现垃圾收集，而且方法区垃圾收集的性价比也很低。

​		方法区（永久代）的垃圾收集主要回收两部分内容：**废弃常量**和**无用的类**。废弃常量的回收和 Java 堆中对象的回收非常类似，这里就不做过多的解释了。类的回收条件就比较苛刻了。要判定一个类是否可以被回收，要满足以下三个条件：

- 该类的所有实例已经被回收；
- 加载该类的 ClassLoader 已经被回收；
- 该类的 Class 对象没有被引用，无法再任何地方通过反射访问该类的方法。



##### 3.垃圾收集算法

###### 1.标记-清除算法

标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：

- 标记阶段：标记出可以回收的对象。
- 清除阶段：回收被标记的对象所占用的空间。

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

- **优点**：实现简单，不需要对象进行移动。
- **缺点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

标记-清除算法的执行的过程如下图所示

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307100324612-4461689.png" alt="image-20200307100324612" style="zoom:30%;" />

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307100342383-4461689.png" alt="image-20200307100342383" style="zoom:30%;" />



###### 2.复制算法

​		为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。

- **优点**：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
- **缺点**：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

复制算法的执行过程如下图所示

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307100425740-4461689.png" alt="image-20200307100425740" style="zoom:30%;" />

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307100439883-4461689.png" alt="image-20200307100439883" style="zoom:30%;" />

​		现在的商业虚拟机都采用这种算法来**回收新生代**，在 IBM 的研究中新生代中的对象 **98% 都是「朝生夕死」**，所以并**不需要按照 1:1 的比例来划分空间**，而是将内存分为一块**较大的 Eden 空间和两块较小的 Survivor 空间**，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中**还存活的对象一次性复制到另一块 Survivor 空间上**，最后清理掉 Eden 和刚才用过的 Survivor 空间。 HotSpot 默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用的内存为**整个新生代容量的 90%**（80%+10%），只有 10% 会被浪费。当然，98% 的对象可回收只是一般场景下的数据，我们没办法保证每次回收后都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要**依赖其它内存（这里指老年代）进行分配担保**。如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来存活的对象时，这些对象将**直接通过分配担保机制进入老年代**。



###### 3.标记-整理算法

​		在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种**标记-整理算法（Mark-Compact）算法**，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。

- **优点**：解决了标记-清理算法存在的内存碎片问题。
- **缺点**：仍需要进行局部对象移动，一定程度上降低了效率。

标记-整理算法的执行过程如下图所示

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307101709817-4461689.png" alt="image-20200307101709817" style="zoom:30%;" />

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307101719762-4461689.png" alt="image-20200307101719762" style="zoom:30%;" />



###### 4.分代收集算法

​		当前商业虚拟机都采用**分代收集**的垃圾收集算法。分代收集算法，顾名思义是根据对象的**存活周期**将内存划分为几块。一般包括**年轻代**、**老年代** 和 **永久代**，如图所示：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307101809113-4461689.png" alt="image-20200307101809113" style="zoom:40%;" />

**新生代（Young generation）**

绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会**很快变得不可达**，所以很多对象被创建在新生代，然后消失。**对象从这个区域消失的过程我们称之为 minor GC**。

新生代 中存在**一个Eden区和两个Survivor区**。新对象会首先分配在Eden中（**如果新对象过大，会直接分配在老年代中**）。在GC中，**Eden中的对象会被移动到Survivor中**，直至对象满足一定的年纪（定义为熬过GC的次数），会被**移动到老年代**。

可以设置新生代和老年代的**相对大小**。这种方式的优点是新生代大小会随着**整个堆大小动态扩展**。参数 -XX:NewRatio 设置老年代与新生代的比例。例如 -XX:NewRatio=8 指定 **老年代/新生代 为8/1**. 老年代 占堆大小的 7/8 ，新生代 占堆大小的 1/8（默认即是 1/8）。

例如：

```Java
-XX:NewSize=64m -XX:MaxNewSize=1024m -XX:NewRatio=8
```


**老年代（Old generation）**

对象没有变得不可达，并且从新生代中存活下来，**会被拷贝到这里**。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的**GC要比新生代要少得多**。对象从老年代中消失的过程，**可以称之为major GC（或者full GC）**。

**永久代（permanent generation）**

像一些类的**层级信息**，**方法数据 和方法信息**（如字节码，栈 和 变量大小），**运行时常量池**（JDK7之后移出永久代），已确定的**符号引用和虚方法表**等等。它们几乎都是静态的并且**很少被卸载和回收**，在JDK8之前的HotSpot虚拟机中，类的这些**“永久的”** 数据存放在一个叫做**永久代的区域**。

永久代是一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小。但是JDK8之后**取消了永久代**，这些元数据被移到了一个与堆不相连的称为**元空间 (Metaspace) 的本地内存区域**。



###### 5.垃圾收集算法小结

​		当执行一次**Minor Collection**时，Eden空间的**存活对象会被复制到To Survivor空间**，并且之前经过一次Minor Collection并在From Survivor空间存活的仍年轻的对象**也会复制到To Survivor空间**。

​		有两种情况Eden空间和From Survivor空间存活的对象不会复制到To Survivor空间，而是**晋升到老年代**。

-   一种是存活的对象的分代年龄超过-XX:MaxTenuringThreshold（用于控制对象经历多少次Minor GC才晋升到老年代）所指定的阈值。
-   另一种是To Survivor空间容量达到阈值。

**当所有存活的对象被复制到To Survivor空间，或者晋升到老年代，也就意味着Eden空间和From Survivor空间剩下的都是可回收对象**，如下图所示。

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307103533473-4461689.png" alt="image-20200307103533473" style="zoom:30%;" />

​		这时GC执行Minor Collection，Eden空间和From Survivor空间都会被清空，而存活的对象都存放在To Survivor空间。接下来将**From Survivor空间和To Survivor空间互换位置**，也就是此前的From Survivor空间成为了现在的To Survivor空间，每次Survivor空间互换都要保证To Survivor空间是空的，这就是复制算法在新生代中的应用。在老年代则**采用了标记-压缩算法**。

​		JDK8堆内存一般是划分为年轻代和老年代，不同年代 根据自身特性采用不同的垃圾收集算法。

​		对于新生代，每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用**复制算法**。因此有了From Survivor和To Survivor区域。

​		对于老年代，因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用**标记-清理算法和标记-整理算法**进行回收。

​		由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，**Minor GC 和 Full GC**。

-   **Minor GC**：新生代垃圾收集。**对新生代进行回收**，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。
-   **Full GC**：也叫 Major GC，**对整个堆进行回收，包括新生代和老年代**（JDK8 取消永久代）。由于Full GC需要对整个堆进行回收，所以**比Minor GC要慢**，因此应该尽可能减少Full GC的次数。它的收集频率较低，耗时较长。

**垃圾收集算法小结**

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%2520Images/image-20200307103944731-4461689.png" alt="image-20200307103944731" style="zoom:33%;" />





##### 4.垃圾收集器

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。以下介绍7种作用于不同分代的收集器，其中用于回收**新生代的收集器包括Serial、PraNew、Parallel Scavenge**，回收**老年代的收集器包括Serial Old、Parallel Old、CMS**，还有用于回收**整个Java堆的G1收集器**。不同收集器之间可以搭配使用。

- Serial收集器（**复制算法**): 新生代单线程收集器，标记和清理都是**单线程**，优点是简单高效；
- ParNew收集器 (**复制算法**): 新生代收并行集器，实际上是Serial收集器的**多线程版本**，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器 (**复制算法**): 新生代并行收集器，追求**高吞吐量，高效利用 CPU**。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等**对交互相应要求不高的场景**；
- Serial Old收集器 (**标记-整理算法**): 老年代**单线程收集器**，Serial收集器的老年代版本；
- Parallel Old收集器 (**标记-整理算法**)： 老年代**并行收集器**，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- CMS(Concurrent Mark Sweep)收集器（**标记-清除算法**）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有**高并发、低停顿的特点**，追求最短GC回收停顿时间。
- G1(Garbage First)收集器 (**标记-整理算法**)： **Java堆并行收集器**，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说**不会产生内存碎片**。此外，G1收集器不同于之前的收集器的一个重要特点是：**G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代**。



##### 5.内存分配与回收优化策略

​		所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。

​		对象的内存分配通常是**在 Java 堆上分配**（随着虚拟机优化技术的诞生，某些场景下也会**在栈上分配**，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将**按照线程优先在 TLAB 上分配**。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：

###### **1.对象优先在 Eden 区分配**

​		多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机**将会发起一次 Minor GC**。如果本次 GC 后还是没有足够的空间，则将启用**分配担保机制在老年代中分配内存**。

这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。

- Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；
- Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。



###### 2.大对象直接进入老年代

​		所谓大对象是指需要大量连续内存空间的对象，**频繁出现大对象是致命的**，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。

​		前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间**发生大量的内存复制**。因此对于大对象都会直接在老年代进行分配。



###### 3.长期存活对象将进入老年代

​		虚拟机采用**分代收集的思想**来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。



###### 4.动态对象年龄判定

​		为了更好的适应不同程序的内存情况，虚拟机**并不是永远要求对象的年龄必需达到某个固定的值**（比如前面说的 15）才会被晋升到老年代，而是会去动态的判断对象年龄。如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，**年龄大于等于该年龄的对象就可以直接进入老年代**。



###### 5.空间分配担保

​		在新生代触发 Minor GC 后，如果 Survivor 中仍然有大量的对象存活，就需要**老年代来进行分配担保**，让 Survivor 区中无法容纳的对象直接进入到老年代。















#### 4.Java虚拟机调优

##### 1.**JVM内存模型及垃圾收集算法**

######  **1.**根据Java虚拟机规范，JVM将内存划分为：

-   New（年轻代）
-   Tenured（年老代）
-   永久代（Perm）

​        其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，**Perm不属于堆内存，有虚拟机直接分配**，但可以通过**-XX:PermSize -XX:MaxPermSize** 等参数调整其大小。

-   年轻代（New）：**年轻代用来存放JVM刚分配的Java对象**

-   年老代（Tenured)：年轻代中经过垃圾回收**没有回收掉的对象将被Copy到年老代**

-   永久代（Perm）：永久代**存放Class、Method元信息**，其大小跟项目的规模、类、方法的量有关，一般**设置为128M就足够**，设置**原则是预留30%的空间**

    **New又分为几个部分**：

-   Eden：**Eden用来存放JVM刚分配的对象**

-   Survivor1

-   Survivro2：**两个Survivor空间一样大**，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被**Copy到Tenured**。显然，**Survivor只是增加了对象在年轻代中的逗留时间**，增加了**被垃圾回收的可能性**。



######  **2.垃圾回收算法**

 垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：

-   Serial算法（单线程）
-   并行算法
-   并发算法

​         JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择**并行算法**，关于选择细节请参考JVM调优文档。 稍微解释下的是，**并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。**所以，并发算法适用于**交互性高的一些程序**。经过观察，并发算法会减少年轻代的大小，其实就是使用了**一个大的年老代**，这反过来跟并行算法相比**吞吐量相对较低**。

​       还有一个问题是，垃圾回收动作何时执行？      

-   当年轻代内存满时，**会引发一次普通GC**，该GC仅回收年轻代。**需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC**
-   当年老代满时**会引发Full GC**，Full GC将会同时回收年轻代、年老代
-   当永久代满时**也会引发Full GC**，会导致Class、Method元信息的**卸载**

​       另一个问题是，**何时**会抛出OutOfMemoryException，**并不是内存被耗空的时候才抛出**

-   JVM98%的时间都**花费在内存回收**
-   每次**回收的内存小于2%**

 满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如**手动打印Heap Dump**。





##### **2.内存泄漏及解决方法**

######  1.系统崩溃前的一些现象：

-   每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s
-   FullGC的次数**越来越多**，最频繁时隔不到1分钟就进行一次FullGC
-   年老代的内存越来越大并且每次FullGC后**年老代没有内存被释放**

 之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。 

######  2.生成堆的dump文件

 通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。 

######  3.分析dump文件

 下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：

1.  Visual VM
2.  IBM HeapAnalyzer
3.  JDK 自带的Hprof工具

 使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。

######  4.分析内存泄漏

 通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。

 另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。

######  5.回归问题

  **Q：为什么崩溃前垃圾回收的时间越来越长？**

  A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据

  **Q：为什么Full GC的次数越来越多？**

  A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收

  **Q:为什么年老代占用的内存越来越大？**

  A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代

 

##### **3.JVM性能调优原理**

 		除了上述内存泄漏外，我们还发现CPU长期不足3%，系统**吞吐量不够**，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。 在CPU负载不足的同时，偶尔会有用户**反映请求的时间过长**，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：

-   **线程池**：解决用户响应时间长的问题
-   **连接池**
-   **JVM启动参数**：调整各代的内存比例和垃圾回收算法，提高吞吐量
-   **程序算法**：改进程序逻辑算法提高性能

######  **1.线程池**

**（java.util.concurrent.ThreadPoolExecutor）**

  大多数JVM6上的应用采用的线程池都是JDK自带的线程池，之所以把成熟的Java线程池进行罗嗦说明，是因为该线程池的行为与我们想象的有点出入。Java线程池有几个重要的配置参数：

-   corePoolSize：核心线程数（最新线程数）
-   maximumPoolSize：最大线程数，超过这个数量的任务会被拒绝，用户可以通过RejectedExecutionHandler接口自定义处理方式
-   keepAliveTime：线程保持活动的时间
-   workQueue：工作队列，存放执行的任务

  Java线程池需要传入一个Queue参数（workQueue）用来存放执行的任务，而对Queue的不同选择，线程池有完全不同的行为：

-   `SynchronousQueue`： **无容量的等待队列**，一个线程的insert操作必须等待另一线程的remove操作，采用这个Queue线程池将会为每个任务分配一个新线程
-   `LinkedBlockingQueue `：**无界队列**，采用该Queue，线程池将忽略maximumPoolSize参数，仅用corePoolSize的线程处理所有的任务，未处理的任务便在LinkedBlockingQueue中排队
-   `ArrayBlockingQueue`： **有界队列**，在有界队列和maximumPoolSize的作用下，程序将**很难被调优**：更大的Queue和小的maximumPoolSize将导致CPU的低负载；小的Queue和大的池，Queue就没起动应有的作用。

​       其实我们的要求很简单，希望线程池能跟连接池一样，能**设置最小线程数、最大线程数**，当最小数<任务<最大数时，应该分配新的线程处理；当任务>最大数时，应该等待有空闲线程再处理该任务。但线程池的设计思路是，任务**应该放到Queue中**，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。当然，要达到我们的目标，必须**对线程池进行一定的封装**，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：

-   以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以**防止线程被无限制的分配**，同时可以通过提高maximumPoolSize来提高系统吞吐量
-   自定义一个RejectedExecutionHandler，当**线程数超过maximumPoolSize时进行处理**，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。

######  **2.连接池**

**（org.apache.commons.dbcp.BasicDataSource）**

 	 在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：

-   Mysql默认**支持100个链接**，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60
-   initialSize：参数是一直打开的连接数
-   minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭
-   timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接
-   maxActive：最大能分配的连接数
-   maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize < x < maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。
-   initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。

######  **3.JVM参数**

  	在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标：

-   **GC的时间足够的小**
-   **GC的次数足够的少**
-   **发生Full GC的周期足够的长**

​        前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。

  （1）针对**JVM堆的设置**，一般可以通过-Xms -Xmx限定其最小、最大值，**为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值**
  （2）**年轻代和年老代将根据默认的比例（1：2）分配堆内存**，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小

  （3）年轻代和年老代设置多大才算合理？这个问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响

-   **更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC**
-   **更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率**
-   如何选择应该依赖应用程序**对象生命周期的分布情况**：如果应用存在大量的临时对象，应该**选择更大的年轻代**；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间

 （4）**在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法**： **-XX:+UseParallelOldGC** ，默认为Serial收集

 （5）**线程堆栈的设置**：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

 （6）可以通过下面的参数打Heap Dump信息

-   -XX:HeapDumpPath
-   -XX:+PrintGCDetails
-   -XX:+PrintGCTimeStamps
-   -Xloggc:/usr/aaa/dump/heap_trace.txt

  通过下面参数可以控制OutOfMemoryError时打印堆的信息

-   -XX:+HeapDumpOnOutOfMemoryError

 请看一下一个时间的Java参数配置：（服务器：Linux 64Bit，8Core×16G）

 **JAVA_OPTS="$JAVA_OPTS -server -Xms3G -Xmx3G -Xss256k -XX:PermSize=128m -XX:MaxPermSize=128m -XX:+UseParallelOldGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/aaa/dump -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/usr/aaa/dump/heap_trace.txt -XX:NewSize=1G -XX:MaxNewSize=1G"**

​		经过观察该配置非常稳定，每次普通GC的时间在10ms左右，Full GC基本不发生，或隔很长很长的时间才发生一次，通过分析dump文件可以发现，每1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用，关于这点请参考附件文档。

######  4.**调优目的与原则**

**调优之前，我们需要记住下面的原则：**

-   1、多数的Java应用不需要在服务器上进行GC优化；
-   2、多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
-   3、在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
-   4、减少创建对象的数量；
-   5、减少使用全局变量和大对象；
-   6、GC优化是到最后不得已才采用的手段；
-   7、在实际使用中，分析GC情况优化代码比优化GC参数要多得多；

**GC优化的目的有两个：**

-   1、将转移到老年代的对象数量降低到最小；
-   2、减少full GC的执行时间；

**一般地，需要做的事情有：**

1、减少使用**全局变量和大对象**；

2、调整新生代的大小到最合适；

3、设置老年代的大小为最合适；

4、选择合适的GC收集器；



###### **5.JVM调优一般步骤**

**1，监控GC的状态**

​		使用各种JVM工具，查看当前日志，**分析当前JVM参数设**置，并且分析当前**堆内存快照和gc日志**，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；

**2，分析结果，判断是否需要优化**

​		如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么**没有必要进行GC优化**；如果GC时间超过1-3秒，或者**频繁GC，则必须优化**；

注：**如果满足下面的指标，则一般不需要进行GC：**

-     **Minor GC执行时间不到50ms；**
-     Minor GC执行不频繁，约**10秒一次**；
-     **Full GC执行时间不到1s；**
-     Full GC执行频率不算频繁，**不低于10分钟1次**；

**3，调整GC类型和内存分配**

​		如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较**优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择**；

**4，不断的分析和调整**

通过不断的试验和试错，分析并找到最合适的参数

**5，全面应用参数**

如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。



##### 4.JVM调优具体参数

###### 1.堆大小设置

JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。

典型设置：

-   **java -Xmx3550m -Xms3550m -Xmn2g -Xss128k**
    -**Xmx**3550m：设置JVM最大可用内存为3550M。
    -**Xms**3550m：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
    -**Xmn**2g：设置**年轻代**大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定**大小为64m**，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
    -**Xss128k**：设置每个**线程的堆栈大小**。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
-   **java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0**
    -XX:**NewRatio**=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
    -XX:**SurvivorRatio**=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
    -XX:**MaxPermSize**=16m:设置持久代大小为16m。
    -XX:**MaxTenuringThreshold**=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象**不经过Survivor区，直接进入年老代**。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。

###### 2.回收器选择

​		JVM给了三种选择：**串行收集器、并行收集器、并发收集器**，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前[系统配置](http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html)进行判断。

​		**1.吞吐量优先的并行收集器**

​		如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。典型配置如下：

-   java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20
    -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。
    -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。

-   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
    -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。

-   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100
    -XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。

-   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
    -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。

    ​	**2.响应时间优先的并发收集器**

​		如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。**典型配置如下：**

-   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
    -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
    -XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。
-   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
    -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
    -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

###### 3.辅助信息

**1.JVM提供了大量命令行参数，打印信息，供调试使用。**

主要有以下一些：

-   -XX:+PrintGC

    ```
    输出形式：[GC 118250K->113543K(130112K), 0.0094143 secs]
    
            [Full GC 121376K->10414K(130112K), 0.0650971 secs]
    ```

-   -XX:+PrintGCDetails

    ```
    输出形式：[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs]
    
            [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs]
    ```

-   -XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用

    ```
    输出形式：11.851: [GC 98328K->93620K(130112K), 0.0082960 secs]
    ```

-   -XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用

    ```
    输出形式：Application time: 0.5291524 seconds
    ```

-   -XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用

    ```
    输出形式：Total time for which application threads were stopped: 0.0468229 seconds
    ```

-   -XX:PrintHeapAtGC:打印GC前后的详细堆栈信息

-   -Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。

###### **4.常见配置汇总**

1.  堆设置
    -   -Xms:初始堆大小
    -   -Xmx:最大堆大小
    -   -XX:NewSize=n:设置年轻代大小
    -   -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
    -   -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
    -   -XX:MaxPermSize=n:设置持久代大小
2.  收集器设置
    -   -XX:+UseSerialGC:设置串行收集器
    -   -XX:+UseParallelGC:设置并行收集器
    -   -XX:+UseParalledlOldGC:设置并行年老代收集器
    -   -XX:+UseConcMarkSweepGC:设置并发收集器
3.  垃圾回收统计信息
    -   -XX:+PrintGC
    -   -XX:+PrintGCDetails
    -   -XX:+PrintGCTimeStamps
    -   -Xloggc:filename
4.  并行收集器设置
    -   -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
    -   -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
    -   -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
5.  并发收集器设置
    -   -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
    -   -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

###### 5.调优总结

**1.年轻代大小选择**

-   响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
-   吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

**2.年老代大小选择**

-   响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要**考虑并发会话率和会话持续时间等一些参数**。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：

    -   并发垃圾收集信息
    -   持久代并发收集次数
    -   传统GC信息
    -   花在年轻代和年老代回收上的时间比例

    减少年轻代和年老代花费的时间，一般会提高应用的效率

-   吞吐量优先的应用：一般**吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代**。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

**3.较小堆引起的碎片问题**

​		因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：

-   -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启**对年老代的压缩**。
-   -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置**多少次Full GC后，对年老代进行压缩**





##### 5.JVM调优实例

###### **实例1：**

​		昨日发现部分开发测试机器出现异常：java.lang.OutOfMemoryError: GC overhead limit exceeded，这个异常代表：GC为了释放**很小的空间却耗费了太多的时间**，其原因一般有两个：1，堆太小，2，有死循环或大对象；笔者首先排除了第2个原因，因为这个应用同时是在线上运行的，如果有问题，早就挂了。所以怀疑是这台机器中堆设置太小；使用ps -ef |grep "java"查看，发现：

![img](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/af00bbf9-50dc-3127-a917-e78aced45e01.png) 

 		该应用的堆区设置只有768m，而机器内存有2g，机器上只跑这一个java应用，没有其他需要占用内存的地方。另外，这个应用比较大，需要占用的内存也比较多；通过上面的情况判断，只需要改变堆中各区域的大小设置即可，于是改成下面的情况：

![img](/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/196da884-1c12-3b4e-9d5a-08300587d5e4.png) 

​		跟踪运行情况发现，相关异常没有再出现；

###### **实例2：**

​		一个服务系统，**经常出现卡顿，分析原因，发现Full GC时间太长**：

```
jstat -gcutil:
S0   S1   E   O    P     YGC YGCT FGC FGCT  GCT
12.16 0.00 5.18 63.78 20.32  54  2.047 5   6.946  8.993 
```

​		分析上面的数据，发现Young GC执行了54次，耗时2.047秒，每次Young GC耗时37ms，在正常范围，**而Full GC执行了5次，耗时6.946秒，每次平均1.389s，数据显示出来的问题是：Full GC耗时较长**，分析该系统的是指发现，**NewRatio=9**，也就是说，新生代和老生代大小之比为1:9，这就是问题的原因：

1，新生代**太小**，导致对象提前进入老年代，触发老年代发生Full GC；

2，老年代较大，进行**Full GC时耗时较大**；

优化的方法是调整NewRatio的值，调整到4，发现Full GC没有再发生，只有Young GC在执行。这就是把对象控制在新生代就清理掉，没有进入老年代（这种做法对一些应用是很有用的，但并不是对所有应用都要这么做） 

###### **实例3：**

​		一应用在性能测试过程中，发现内存占用率很高，Full GC频繁，使用**sudo -u admin -H  jmap -dump:format=b,file=文件名.hprof pid** 来dump内存，生成dump文件，并使用Eclipse下的mat差距进行分析，发现：

<img src="/Users/xiaoxiangyuzhu/Pictures/Typora%20Images/image-20200406125318829.png" alt="image-20200406125318829" style="zoom:50%;" />
 		从图中可以看出，这个线程存在问题，队列LinkedBlockingQueue所引用的**大量对象并未释放**，导致整个线程占用**内存高达378m**，此时通知开发人员进行代码优化，将相关对象释放掉即可。

